:doctype: book
:encoding: utf-8
:lang: en
:toc: macro
:toc-title: Table of contents
:toclevels: 5

:toc-position: left

:appendix-caption: Annex
:listing-caption: Listing

:numbered:
:sectanchors:
:sectnumlevels: 5

[[JSON_Schema]]
= JSON Schema

(since v2.10.0)

[[Overview]]
== Overview

This target derives a JSON Schema representation from an application
schema in UML.

NOTE: A number of configuration options and extensions have been
implemented. They are documented in detail in the
_https://docs.ogc.org/per/20-012.html[OGC UGAS-2020 Engineering
Report]_. The report also documents which model transformations may need
to be applied before executing this target, for example to transform
association classes. Therefore, if you are looking for a complete
introduction of the conversion from UML to JSON Schema, read the
according chapter in the OGC Engineering Report first. This page
provides a quick reference of the available conversion rules,
parameters, and configuration elements.

[[Configuration]]
== Configuration

[[Class]]
=== Class

The class for the Target implementation is
_de.interactive_instruments.ShapeChange.Target.JSON.JsonSchemaTarget._

[[Conversion_Rules]]
=== Conversion Rules

The behavior for processing a model is primarily controlled through
conversion rules. In addition, parameters and other configuration
elements (like map entries) influence the way a schema is processed. An
encoding rule represents a specific set of conversion rules.

An encoding rule is defined by an <EncodingRule> element.

Example:

[source,xml,linenumbers]
----------
<EncodingRule name="myGeoJson" extends="defaultGeoJson">
 <rule name="rule-json-cls-basictype"/>
 <rule name="rule-json-cls-codelist-uri-format"/>
 <rule name="rule-json-cls-name-as-entityType"/>
 <rule name="rule-json-cls-union-propertyCount"/>
 <rule name="rule-json-cls-valueTypeOptions"/>
</EncodingRule>
----------

The *name* attribute of the <EncodingRule> element defines the
identifier of the encoding rule to be used in the
xref:./JSON_Schema.adoc#defaultEncodingRule[defaultEncodingRule]
parameter.

NOTE: The encoding rules 'defaultGeoJson' and 'defaultPlainJson' are
pre-configured in ShapeChange. They can thus be used as-is, without the
need to explicitly define them in the configuration. They can also be
extended as required (see the example).

The optional *extends* attribute of the <EncodingRule> element includes
all rules from the referenced encoding rule in this encoding rule, too.

Each *<rule>* references either a conversion rule or - possibly in the
future - a xref:../application schemas/UML_profile.adoc[requirement
or recommendation] to be tested before the conversion process.

This target supports the rules defined in the following subsections.


[[rule-json-all-documentation]]
==== rule-json-all-documentation

(since v2.14.0)

With __rule-json-all-documentation__, descriptive information of application schema elements (packages, classes, and properties) can be encoded via JSON Schema _annotations_.

[NOTE]
======
_Annotations_ represent one category of JSON Schema keywords. _Annotations_ attach information that applications may use as they see fit. The other categories are _assertions_, which validate that a JSON instance satisfies constraints, and _applicators_, which apply subschemas to parts of the instance and combine their results.

======

Descriptive information of a model element in ShapeChange, i.e., properties (attributes and association roles), classes, and packages, includes the pieces of information, called _descriptors_, that are documented in <<table_descriptors>>.

NOTE: A model element can have all, a subset, or none of these descriptors.

[#table_descriptors,reftext='{table-caption} {counter:table-num}']
.Well-known descriptors
[cols="1,3a",options="header"]
|====================
| Descriptor Name +
(and ID) | Explanation
| Name +
(name) | The name of the model element (as named in the source UML, i.e., using upper and lower camel case).
| Alias +
(alias) | An alternative, human-readable name for the model element.
| Definition +
(definition) | The normative specification of the model element.
| Description +
(description) | Additional information about the model element.
| Documentation +
(documentation) | The overall documentation of the model element. May be structured, containing other descriptors (such as definition and description).
| Example(s) +
(example) | Example(s) illustrating the model element.
| Global identifier +
(globalIdentifier) | The globally unique identifier of the model element; that is, unique across models.
| Legal basis +
(legalBasis) | The legal basis for the model element.
| Data capture statement(s) +
(dataCaptureStatement) | Statement(s) describing how to capture instances of this model element from the real world.
| Primary code +
(primaryCode) | The primary code for this model element. +

NOTE: The main code for a model element should be assigned to this descriptor. The primary code may be the only one. Optional additional tagged values may be added for other codes.
|====================

NOTE: The descriptor ID is used in ShapeChange configuration elements that define JSON Schema annotations.

Typically, a community has a preferred way to model and encode this information. For example, one community may want to encode the description of a model element via the "description" annotation, while another may prefer to encode the values of multiple descriptors of a model element within a single "description" annotation.

ShapeChange can support this type of diversity through _JSON Schema annotation_ elements. An annotation element specifies how the content of a specific JSON Schema annotation (that shall be generated while converting a model element) shall be constructed. The annotation element takes into account that a UML model element may not have an actual value for a descriptor, and that some descriptors can have multiple values, e.g., the descriptor _example_.

In addition to the well-known descriptors (see <<table_descriptors,previous table>>), additional descriptive information can be incorporated through UML tagged values from the application schema.

For details about configuring JSON Schema annotation elements, see <<Annotations>>.


[[rule-json-all-notEncoded]]
==== rule-json-all-notEncoded

This conversion rule suppresses the conversion to JSON Schema of any
model elements (more specifically: application schemas, classes, and
properties) for which the "jsonEncodingRule" tag is set to "notEncoded".

NOTE: The encoding rule "notEncoded" is defined in the standard rules,
which can be included in the target configuration via:

<xi:include
href="https://shapechange.net/resources/config/StandardRules.xml" />

[[rule-json-cls-basictype]]
==== rule-json-cls-basictype

If a direct or indirect supertype of an application schema class is
mapped to one of the simple JSON Schema types _string_, _number_,
_integer_, or _boolean_, then under _rule-json-cls-basictype_ that class
represents a so called _basic type_.

NOTE: Uses of the stereotype \<<BasicType>> with application schema classes are ignored by this conversion rule.

A basic type does not define a JSON object. It represents a simple data
value, e.g. a string. The JSON Schema definition of a basic type thus
defines a simple JSON Schema type. A basic type can be restricted using
a number of JSON Schema keywords. The following table defines which
tagged values can be used to define these restrictions for a basic type,
and which restrictions are available for which simple JSON Schema type.

[width="100%",cols="2,3,2",options="header",]
|===
|JSON Schema keyword |tagged value to define the restriction |applicable
JSON Schema type(s)
|format |_jsonFormat_ |string, number, integer

|maxLength |_length_, _maxLength_, or _size_ |string

|pattern |_jsonPattern_ |string

|minimum +
(inclusive) |_rangeMinimum_ |number, integer

|maximum +
(inclusive) |_rangeMaximum_ |number, integer
|===

[[rule-json-cls-codelist-link]]
==== rule-json-cls-codelist-link

This rule results in the conversion of a code list as a reference to the
JSON Schema defining a link object. That reference must explicitly be
configured using the target parameter
xref:./JSON_Schema.adoc#linkObjectUri[linkObjectUri].

[[rule-json-cls-codelist-uri-format]]
==== rule-json-cls-codelist-uri-format

With this rule, all code lists are represented by a JSON Schema that
restricts the type to "string", and states that the "format" is "uri"
(as defined by
https://tools.ietf.org/html/draft-handrews-json-schema-validation-02#section-7.3.5[JSON
Schema validation, section 7.3.5]).

[[rule-json-cls-defaultGeometry-multipleGeometryProperties]]
==== rule-json-cls-defaultGeometry-multipleGeometryProperties

This conversion rule is typically used in case that a) a GeoJSON
compliant encoding shall be created, and b) for application schemas with
classes that have multiple geometry properties.

With this rule, a geometry property is identified as default geometry by
setting tagged value _defaultGeometry_ on the property to the value
`true`. That property will then be encoded as a top-level "geometry"
member. If multiple such properties exist (potentially inherited), none
of them is selected as default geometry (because no informed choice can
be made) and an error will be logged.

[[rule-json-cls-defaultGeometry-singleGeometryProperty]]
==== rule-json-cls-defaultGeometry-singleGeometryProperty

This conversion rule is typically used in case that a) a GeoJSON
compliant encoding shall be created, and b) for application schemas with
classes that have at most one geometry property.

With this rule, the geometry property of a class represents the default
geometry, and is encoded as the top-level "geometry" member. If a class
has multiple - potentially inherited - geometry properties with
different names, none of them is selected as default geometry (because
no informed choice can be made) and ShapeChange will log an error.

[[rule-json-cls-identifierForTypeWithIdentity]]
==== rule-json-cls-identifierForTypeWithIdentity

With _rule-json-cls-identifierForTypeWithIdentity_, an identifier JSON
member will be added to the JSON object that represents a type with
identity (feature type or object type). The key and value type of that
member can be configured using ShapeChange JSON Schema target
parameters:

* _xref:./JSON_Schema.adoc#objectIdentifierName[objectIdentifierName]_:
"id" (the default) or any other suitable string that does not conflict
with other member names);
* _xref:./JSON_Schema.adoc#objectIdentifierType[objectIdentifierType]_:
"string" (the default), "number", or "string, number";
* _xref:./JSON_Schema.adoc#objectIdentifierRequired[objectIdentifierRequired]_:
"false" (the default) or "true" is used to define if the property is
optional or required.

[[rule-json-cls-identifierStereotype]]
==== rule-json-cls-identifierStereotype

This conversion rule assumes that all types with identity (feature type
or object type) have an attribute with stereotype \<<identifier>>
(directly, or inherited from a supertype). That attribute is used to
encode the identifier. The rule is typically used in conjunction with
xref:./JSON_Schema.adoc#rule-json-cls-ignoreIdentifier[rule-json-cls-ignoreIdentifier],
in order to detect identifier properties and not encode them (e.g.
because a JSON Schema that applies to all types with identity already
defines an identifier member).

NOTE: If the maximum multiplicity of an \<<identifier>> attribute is
greater than 1, ShapeChange will log an error.

[[rule-json-cls-ignoreIdentifier]]
==== rule-json-cls-ignoreIdentifier

With this rule, the identifier of a type with identity (feature type or
object type) will be encoded using an identifier member that is provided
by a common base type (e.g. the "id" member of a GeoJSON Feature, to
which a generalization relationship exists for a given feature type -
see
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_).
That means that no additional identifier property is created.
_xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity]_
is therefore overridden by
_xref:./JSON_Schema.adoc#rule-json-cls-ignoreIdentifier[rule-json-cls-ignoreIdentifier]_.
Also, all identifier properties that are identified by
_xref:./JSON_Schema.adoc#rule-json-cls-identifierStereotype[rule-json-cls-identifierStereotype]_
- if also included in the encoding rule - will simply be ignored when
encoding the type with identity.

[[rule-json-cls-name-as-anchor]]
==== rule-json-cls-name-as-anchor

With _rule-json-cls-name-as-anchor_, the name of a class is encoded as
an "$anchor", which is added at the start of the schema definition of
the class (within the definitions schema). Schema definitions that have
an "$anchor" can be referenced using the plain text value of the anchor
as fragment identifier, instead of using a more complex JSON Pointer.

NOTE: The "$anchor" keyword was added in JSON Schema draft 2019-09. It
replaces the somewhat ambiguous use of the "$id" keyword in JSON Schema
draft 07 to define plain name fragment identifiers for subschemas.

[[rule-json-cls-name-as-entityType]]
==== rule-json-cls-name-as-entityType

The rule adds another JSON member to the JSON object which represents
the class (a feature, object, or data type) that is being converted. The
name of the JSON member can be configured using the target parameter
_xref:./JSON_Schema.adoc#entityTypeName[entityTypeName]_.
The JSON member is required and string-valued. It should be used to
encode the name of the type that is represented by the JSON object.

An example for the benefit of encoding the type name in JSON objects is
given in
http://docs.opengeospatial.org/per/18-091r2.html#JSON_LD[chapter 6 of
the OGC Testbed-14: Application Schemas and JSON Technologies
Engineering Report]: Having a key within a JSON object with a string
value that identifies the type of the object allows that object to be
mapped to RDF. More specifically, the string value can be mapped to an
IRI that identifies the type of an RDFS resource.

There are also some cases in which
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
is ignored or conditional:

* To prevent the addition of unnecessary JSON members (here: because the
JSON member would already be inherited), the rule is ignored for a type
T if T is a subtype and
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
already applies to one of its supertypes.
* By default, the rule does not apply to unions, enumerations, and code
lists. +
However, if
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType-union[rule-json-cls-name-as-entityType-union]_
is enabled together with
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_,
then the latter also applies to unions.
* Since v2.14.0, encoding infos from external schemas - either from a base schema or from 
a supertype that is mapped to an external schema - can inform about the presence of an
entity type member in the external schema. If such an external schema applies to a given
type, then this conversion rule is ignored for that type.
** The base schema assignment is enabled via _xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_ (and the target parameters identified there), and encoding infos for the base schema can be given via the target parameters _xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForDataTypes_encodingInfos[baseJsonSchemaDefinitionForDataTypes_encodingInfos]_,
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForObjectTypes_encodingInfos[baseJsonSchemaDefinitionForObjectTypes_encodingInfos]_, and _xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForFeatureTypes_encodingInfos[baseJsonSchemaDefinitionForFeatureTypes_encodingInfos]_.
** Type mappings are documented <<Map_Entries,here>>. The encoding infos of a mapped type
are conveyed via map entry parameter <<Parameter_encodingInfos,encodingInfos>>.

[[rule-json-cls-name-as-entityType-union]]
==== rule-json-cls-name-as-entityType-union

If this rule is enabled together with
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_,
then the latter also applies to unions.

NOTE: _xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType-union[rule-json-cls-name-as-entityType-union]_
has been implemented because with
_xref:./JSON_Schema.adoc#rule-json-cls-union-propertyCount[rule-json-cls-union-propertyCount]_
unions are converted to JSON objects. The
xref:../targets/ontology/UML_to_RDF_OWL_based_on_ISO_IS_19150_2.adoc[ontology
target of ShapeChange] encodes a union as a class, with cardinality
restrictions to ensure that only one option (defined by the union) is
used. For further details, also see the
http://docs.opengeospatial.org/per/16-020.html#rdf_cr_class_union[OGC
Testbed-12 ShapeChange Engineering Report]. This is an argument for
applying
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
to unions, because it would support a JSON-LD based mapping to the union
class in RDF/OWL.

[[rule-json-cls-nestedProperties]]
==== rule-json-cls-nestedProperties

By default, the properties of a type with identity (feature type or
object type) are converted to first-level properties of the resulting
JSON object. In GeoJSON, feature properties are encoded within the
GeoJSON "properties" member. Notable exceptions from that rule are the
GeoJSON members "id", "geometry", and "bbox". In order to produce a JSON
Schema that converts the properties of a type with identity to be
encoded within a nested "properties" member - minus any properties that
are mapped to the other aforementioned GeoJSON keys - the conversion
rule _rule-json-cls-nestedProperties_ needs to be included in the
encoding rule.

[[rule-json-cls-restrictExternalEntityTypeMember]]
==== rule-json-cls-restrictExternalEntityTypeMember

(since v2.14.0)

This rule can be used to restrict the entity type member that 
the JSON Schema definition of a class (feature, object, or data type) 
receives through an external JSON Schema definition, 
either through mapping of a direct supertype to such a schema definition, or by 
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_.

The only restriction right now is to make the entity type member
a required property. 

[NOTE]
======
The according constraint is only defined for the last 
segment of the entity type member path. 

The restrictions are only defined in
the JSON Schema definition of the class that directly "inherits" the 
external JSON Schema definition (thereby avoiding duplicate constraints 
in JSON Schema definitions of potentially existing subtypes of that class).

The restriction of the entity type member will not be encoded in 
case that the encoding infos for the external JSON
Schema definition (given via map entry or the target parameters
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForFeatureTypes_encodingInfos[baseJsonSchemaDefinitionForFeatureTypes_encodingInfos]_,
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForObjectTypes_encodingInfos[baseJsonSchemaDefinitionForObjectTypes_encodingInfos]_, or
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForDataTypes_encodingInfos[baseJsonSchemaDefinitionForDataTypes_encodingInfos]_) 
indicate that the restriction would be superfluous. 
The log will inform the user about such a situation.

The rule does not apply if the entity type member was generated by 
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_.

======

[[rule-json-cls-restrictExternalIdentifierMember]]
==== rule-json-cls-restrictExternalIdentifierMember

(since v2.14.0)

This rule can be used to restrict the identifier member that 
the JSON Schema definition of a class (feature, object, or data type) 
receives through an external JSON Schema definition, 
either through mapping of a direct supertype to such a schema definition, or by 
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_.
The restrictions are defined by parameter _xref:./JSON_Schema.adoc#idMemberEncodingRestrictions[idMemberEncodingRestrictions]_. 

[NOTE]
======
The restrictions are only defined in the JSON Schema definition of 
the class that directly "inherits" the external JSON Schema 
definition (thereby avoiding duplicate constraints in JSON Schema 
definitions of potentially existing subtypes of that class).

Restrictions for the identifier member (concerning its type, format, obligation),
defined by target parameter _idMemberEncodingRestrictions_,
will not be encoded in case that the encoding infos for the external JSON
Schema definition (given via map entry or the target parameters
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForFeatureTypes_encodingInfos[baseJsonSchemaDefinitionForFeatureTypes_encodingInfos]_,
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForObjectTypes_encodingInfos[baseJsonSchemaDefinitionForObjectTypes_encodingInfos]_, or
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForDataTypes_encodingInfos[baseJsonSchemaDefinitionForDataTypes_encodingInfos]_)
indicate that such restrictions would be incompatible or superfluous. 
The log will inform the user about such a situation.

The rule does not apply if the identifier member was generated by 
_xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity]_ or
_xref:./JSON_Schema.adoc#rule-json-cls-identifierStereotype[rule-json-cls-identifierStereotype]_.
But note that both of these rules are ignored if _xref:./JSON_Schema.adoc#rule-json-cls-ignoreIdentifier[rule-json-cls-ignoreIdentifier]_ applies, in case of which
_rule-json-cls-restrictExternalIdentifierMember_ indeed does apply.

======

[[rule-json-cls-union-propertyCount]]
==== rule-json-cls-union-propertyCount

With this rule, a \<<union>> is converted to the JSON Schema definition
of a JSON object. Each union option is represented as an optional member
of the JSON object. The choice between the options defined by the union
is encoded using "maxProperties" = "minProperties" = 1. That is, the
number of members that are allowed for the JSON object is restricted to
exactly one.

An `"additionalProperties": false` is used to prevent any undefined
properties.

[[rule-json-cls-union-typeDiscriminator]]
==== rule-json-cls-union-typeDiscriminator

With this rule, a \<<union>> is converted to a JSON Schema definition
that represents a choice between the value types of the union
properties.

* If the value types are only simple, without a specific format
definition, then the JSON Schema will only contain a "type" member, with
an array of the simple types.
* Otherwise, a "oneOf" member is added to the JSON Schema definition,
with:
** one "$ref" per non-simple type,
** one "type" for all simple types without specific format, and
** one "type" per simple type with specific format.

[[rule-json-cls-valueTypeOptions]]
==== rule-json-cls-valueTypeOptions

This rule looks for tagged value _valueTypeOptions_ on a class (that is
not a basic type, enumeration, or code list). If the tag exists and has
a value, it defines which types are allowed as value type for a given
UML property of the class. Note that this UML property can be directly
defined on the class but also be inherited from a supertype. The
property can also originally have been an association role that belonged
to an association class. The conversion rule ensures that instead of the
actual value type of the property, only one of the allowed types is
encoded as type definition in the JSON Schema. The conversion also takes
into account that the property may have been a role of an association
class. The restriction to a set of allowed types uses an if-then-else
construct, which depends on the presence of a type identifying member in
property values, and thus _rule-json-cls-valueTypeOptions_ should always
be used in combination
with _rule-xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[json-cls-name-as-entityType]_.
Note that value type restrictions (defined on a subtype) of inherited
UML properties will result in these properties being explicitly defined
in the JSON Schema definition of the subtype.

NOTE: Value type options can be parsed from OCL constraints using
transformation
xref:../transformations/Constraint_Converter.adoc#rule-trf-cls-constraints-valueTypeRestrictionToTV-exclusion[rule-trf-cls-constraints-valueTypeRestrictionToTV-exclusion]
of the Constraint Converter.

[[rule-json-cls-virtualGeneralization]]
==== rule-json-cls-virtualGeneralization

It is often useful to encode all classes with a certain stereotype with
a common base type. The generalization relationship to such a base type
is often implied with the stereotype, for a given encoding. In GML, for
example, the common base type for classes with stereotype
\<<featureType>> is gml:AbstractFeature. Rather than explicitly modeling
such a base type (e.g. _AnyFeature_ defined by ISO 19109), as well as
explicitly modeling generalization relationships to the base type, the
encoding rule typically takes care of adding that relationship to
relevant schema types.

This kind of virtual generalization is supported via
_rule-json-cls-virtualGeneralization_. The rule adds generalization
relationships to specific kinds of classes - if a) according ShapeChange
JSON Schema target parameters have been set, and b) the class does not
already have that generalization relationship via one of its supertypes:

* feature type - configuration parameter
xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForFeatureTypes[_baseJsonSchemaDefinitionForFeatureTypes_]
* object type - configuration parameter
xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForObjectTypes[_baseJsonSchemaDefinitionForObjectTypes_]
* data type - configuration parameter
xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForDataTypes[_baseJsonSchemaDefinitionForDataTypes_]

The parameter value shall be a URI to reference the JSON Schema that
defines the common base type. For example, in order for all feature
types to use the GeoJSON Feature definition as common base, set
`baseJsonSchemaDefinitionForFeatureTypes = https://geojson.org/schema/Feature.json`.

NOTE: The parameters do not have a default value. If a parameter is not
set or does not have a value, then _rule-json-cls-virtualGeneralization_
will not have an effect for the kind of class (feature, object, or data
type) for which the parameter applies.

The virtual generalization relationship is implemented by converting the
class to a JSON Schema that consists of an "allOf" with two subschemas:
the first being a "$ref" with the URI defined by the target parameter,
the second being the schema produced by applying the other conversion
rules to the class (the only exception being
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-anchor[rule-json-cls-name-as-anchor]_,
because the "$anchor" created by that rule is not encoded in the second
subschema, but in the schema that contains the "allOf").

[[rule-json-prop-derivedAsReadOnly]]
==== rule-json-prop-derivedAsReadOnly

With this rule, a UML property marked as derived will be encoded with
`"readOnly": true`.

[[rule-json-prop-initialValueAsDefault]]
==== rule-json-prop-initialValueAsDefault

With this rule, the JSON Schema definition of a UML attribute that has
an initial value, is not owned by an enumeration or code list, and whose
value type is mapped to "string", "number", or "boolean", will include
the "default" annotation with that value.

NOTE: The value of the annotation can have any JSON value type. The
initial value is encoded accordingly: quoted, if the property type is
"string", unquoted if the property type is "number", and true if the
property type is "boolean" and the initial value is equal to, ignoring
case, "true"; otherwise the value will be false. Theoretically, the
default value can also be a JSON array or object, but that cannot be
represented in UML and thus is not a relevant use case.

[[rule-json-prop-readOnly]]
==== rule-json-prop-readOnly

With this rule, the JSON Schema definition of a UML property that is
read only or fixed will include the "readOnly" annotation with JSON
value true.

[[rule-json-prop-voidable]]
==== rule-json-prop-voidable

With this rule, the JSON Schema of a UML property with stereotype
\<<voidable>>, or with tagged value _nillable_ = true, is defined in a
way that only allows either a null value or a(n array of) actual
value(s).

* If the UML property has maximum multiplicity 1, then a simple "type"
restriction with value "null" is added to the type definition that is
produced for the property.
* Otherwise - the maximum multiplicity is greater than 1 - a choice
(encoded using the "oneOf" keyword) between a "null" value and an array
of actual values will be created.

[[Rule_execution_priority_and_dependencies]]
=== Rule execution priority and dependencies

Some of the conversion rules supported by this target address the same
conversion aspects. When conflicting conversion rules are included in
the encoding rule, ShapeChange usually only executes one of them. This
section documents the execution priorities and dependencies of rules
that address the same conversion aspects.

[[Code_lists]]
==== Code lists

The default behavior for encoding code lists is overridden whenever
either
xref:./JSON_Schema.adoc#rule-json-cls-codelist-link[rule-json-cls-codelist-link]
or
xref:./JSON_Schema.adoc#rule-json-cls-codelist-uri-format[rule-json-cls-codelist-uri-format]
is in the encoding rule.

These conversion rules are executed with the following priority:

. xref:./JSON_Schema.adoc#rule-json-cls-codelist-uri-format[rule-json-cls-codelist-uri-format]
. xref:./JSON_Schema.adoc#rule-json-cls-codelist-link[rule-json-cls-codelist-link]

[[Identifier]]
==== Identifier

With
xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity],
an identifier member can be added to the JSON Schema representation of a
type with identity (feature type or object type). That rule will be
ignored if
xref:./JSON_Schema.adoc#rule-json-cls-ignoreIdentifier[rule-json-cls-ignoreIdentifier]
also applies to the type with identity.

[[Union]]
==== Union

The rules for converting unions are executed with the following
priority:

* xref:./JSON_Schema.adoc#rule-json-cls-union-typeDiscriminator[rule-json-cls-union-typeDiscriminator]
* xref:./JSON_Schema.adoc#rule-json-cls-union-propertyCount[rule-json-cls-union-propertyCount]

[[Parameters]]
=== Parameters

This target supports the parameters defined in the following
subsections.

[[baseJsonSchemaDefinitionForDataTypes]]
==== baseJsonSchemaDefinitionForDataTypes

Required / Optional: optional

Type: URI

Default Value: _none_

Explanation: Reference to the JSON Schema definition which shall be
added to a data type in order to represent an additional generalization
relationship under
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_


[[baseJsonSchemaDefinitionForDataTypes_encodingInfos]]
==== baseJsonSchemaDefinitionForDataTypes_encodingInfos

(since v2.14.0)

Required / Optional: optional

Type: String

Default Value: _none_

Explanation: Provides additional information about the JSON structure 
that is represented by the JSON Schema definition given by parameter 
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForDataTypes[baseJsonSchemaDefinitionForDataTypes]_.
The additional information can be relevant for creating a JSON encoding
for data types (e.g., restricting an entity type member).

The value of this parameter follows the structure of the the map entry 
parameter _xref:./JSON_Schema.adoc#Parameter_encodingInfos[encodingInfos]_.
The semicolon is used as separator. However, no curly braces are used. Example: 

`<TargetParameter name="baseJsonSchemaDefinitionForDataTypes_encodingInfos" value="entityTypeMemberPath=type;entityTypeMemberRequired=false"/>`

Applies to Rule(s):

* _xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalEntityTypeMember[rule-json-cls-restrictExternalEntityTypeMember]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalIdentifierMember[rule-json-cls-restrictExternalIdentifierMember]_


[[baseJsonSchemaDefinitionForFeatureTypes]]
==== baseJsonSchemaDefinitionForFeatureTypes

Required / Optional: optional

Type: URI

Default Value: _none_

Explanation: Reference to the JSON Schema definition which shall be
added to a feature type in order to represent an additional
generalization relationship under
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_

[[baseJsonSchemaDefinitionForFeatureTypes_encodingInfos]]
==== baseJsonSchemaDefinitionForFeatureTypes_encodingInfos

(since v2.14.0)

Required / Optional: optional

Type: String

Default Value: _none_

Explanation: Provides additional information about the JSON structure 
that is represented by the JSON Schema definition given by parameter 
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForFeatureTypes[baseJsonSchemaDefinitionForFeatureTypes]_.
The additional information can be relevant for creating a JSON encoding
for feature types (e.g., restricting an entity type member).

The value of this parameter follows the structure of the the map entry 
parameter _xref:./JSON_Schema.adoc#Parameter_encodingInfos[encodingInfos]_.
The semicolon is used as separator. However, no curly braces are used. Example: 

`<TargetParameter name="baseJsonSchemaDefinitionForFeatureTypes_encodingInfos" value="entityTypeMemberPath=featureType;entityTypeMemberRequired=false;idMemberPath=id;idMemberTypes=string,number;idMemberRequired=false"/>`

Applies to Rule(s):

* _xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalEntityTypeMember[rule-json-cls-restrictExternalEntityTypeMember]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalIdentifierMember[rule-json-cls-restrictExternalIdentifierMember]_

[[baseJsonSchemaDefinitionForObjectTypes]]
==== baseJsonSchemaDefinitionForObjectTypes

Required / Optional: optional

Type: URI

Default Value: _none_

Explanation: Reference to the JSON Schema definition which shall be
added to an object type in order to represent an additional
generalization relationship under
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-virtualGeneralization[rule-json-cls-virtualGeneralization]_

[[baseJsonSchemaDefinitionForObjectTypes_encodingInfos]]
==== baseJsonSchemaDefinitionForObjectTypes_encodingInfos

(since v2.14.0)

Required / Optional: optional

Type: String

Default Value: _none_

Explanation: Provides additional information about the JSON structure 
that is represented by the JSON Schema definition given by parameter 
_xref:./JSON_Schema.adoc#baseJsonSchemaDefinitionForObjectTypes[baseJsonSchemaDefinitionForObjectTypes]_.
The additional information can be relevant for creating a JSON encoding
for object types (e.g., restricting an entity type member).

The value of this parameter follows the structure of the the map entry 
parameter _xref:./JSON_Schema.adoc#Parameter_encodingInfos[encodingInfos]_.
The semicolon is used as separator. However, no curly braces are used. Example: 

`<TargetParameter name="baseJsonSchemaDefinitionForObjectTypes_encodingInfos" value="entityTypeMemberPath=type;entityTypeMemberRequired=false;idMemberPath=id;idMemberTypes=string;idMemberRequired=false"/>`

Applies to Rule(s):

* _xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalEntityTypeMember[rule-json-cls-restrictExternalEntityTypeMember]_
* _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalIdentifierMember[rule-json-cls-restrictExternalIdentifierMember]_

[[byReferenceJsonSchemaDefinition]]
==== byReferenceJsonSchemaDefinition

Required / Optional: optional

Type: URI

Default Value: _none_

Explanation: References a JSON Schema definition which shall be used to
encode the value of a UML property "by reference", i.e. somehow link to
the actual value. That is relevant for cases in which tag
_inlineOrByReference_ of the UML property (taking into account target
parameter
xref:./JSON_Schema.adoc#inlineOrByReferenceDefault[inlineOrByReferenceDefault])
has value _byReference_ or _inlineOrByReference_. By setting this
parameter, the default encoding for the "by reference" case - which is
"type": "string", "format": "uri" - can be overridden.

Applies to Rule(s): _none - default behavior_

[[defaultEncodingRule]]
==== defaultEncodingRule

Required / Optional: optional

Type: String

Default Value: *

Explanation: The identifier of the default encoding rule governing the
conversion to JSON Schema. To use a custom encoding rule defined in the
configuration, simply provide the name of the custom encoding rule via
this parameter.

Applies to Rule(s): _none_ - default behavior

[[entityTypeName]]
==== entityTypeName

Required / Optional: optional

Type: String

Default Value: "entityType"

Explanation: The name of the JSON member to be added to a JSON object in
order to encode the type represented by that object.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-name-as-entityType[rule-json-cls-name-as-entityType]_

[[idMemberEncodingRestrictions]]
==== idMemberEncodingRestrictions

(since v2.14.0)

Required / Optional: optional

Type: 

Default Value: _none_

Explanation: Can be used to restrict the identifier member
that is incorporated from an external JSON Schema definition.
The value is a semicolon-separated list of restrictions:

* typeRestriction: For restricting the type of the
ID member. The value is either "string", "number", or "integer".
* formatRestriction: For restricting the format of the
ID member. The value is a comma-separated list of values for
JSON Schema keyword "format".
* memberRequired: The presence of this key (i.e., without a specific value)
defines that the ID member shall be declared as a required property.
Note that the according constraint is only defined for the last 
segment of the ID member path.

Example: `<TargetParameter name="idMemberEncodingRestrictions" value="typeRestriction=string;formatRestriction=uuid;memberRequired"/>`

Applies to Rule(s): _xref:./JSON_Schema.adoc#rule-json-cls-restrictExternalIdentifierMember[rule-json-cls-restrictExternalIdentifierMember]_


[[inlineOrByReferenceDefault]]
==== inlineOrByReferenceDefault

Required / Optional: optional

Type: Enumeration, one of "inline", "byReference", "inlineOrByReference"

Default Value: "byReference"

Explanation: Defines the default value for tag _inlineOrByReference_ of
a UML property, in case that tag is undefined or has an empty value for
the property.

Applies to Rule(s): _none - default behavior_

[[jsonBaseUri]]
==== jsonBaseUri

Required / Optional: optional

Type: URI

Default Value: http://example.org/FIXME

Explanation: The base URI, used to construct the value of the "$id"
members of resulting JSON Schemas.

NOTE: If the tagged value _jsonBaseUri_ of an application schema has a
non empty value, then that value will be used as base URI for all JSON
Schemas produced for the content of that application schema.

Applies to Rule(s): _none - default behavior_

[[jsonSchemaVersion]]
==== jsonSchemaVersion

Required / Optional: optional

Type: Enumeration, one of "2019-09", "draft-07", "OpenApi30"

Default Value: "2019-09"

Explanation: Specifies the version of the resulting JSON Schemas.

Applies to Rule(s): _none - default behavior_

[[linkObjectUri]]
==== linkObjectUri

Required / Optional: optional

Type: URL

Default Value: _none_

Explanation: Reference to the JSON Schema of the "Link" object.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-codelist-link[rule-json-cls-codelist-link]_

[[objectIdentifierName]]
==== objectIdentifierName

Required / Optional: optional

Type: String

Default Value: "id"

Explanation: Name of the JSON member to be added to a JSON object that
represents the type with identity.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity]_

[[objectIdentifierRequired]]
==== objectIdentifierRequired

Required / Optional: optional

Type: Boolean

Default Value: false

Explanation: "false", if the new object identifier member shall not be
required, else "true"

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity]_

[[objectIdentifierType]]
==== objectIdentifierType

Required / Optional: optional

Type: String - one of "string", "number", or a (comma-separated)
combination thereof

Default Value: "string"

Explanation: Value type of the JSON member to be added to a JSON object
that represents the type with identity.

Applies to Rule(s):
_xref:./JSON_Schema.adoc#rule-json-cls-identifierForTypeWithIdentity[rule-json-cls-identifierForTypeWithIdentity]_

[[outputDirectory]]
==== outputDirectory

Required / Optional: optional

Type: String

Default Value: <the current run directory>

Explanation: The path to which the JSON Schema file(s) will be written.

Applies to Rule(s): _none_ - this is a common target parameter

[[prettyPrint]]
==== prettyPrint

Type: Boolean

Default Value: true

Explanation: True if the resulting json schemas shall be pretty printed,
else false.

Applies to Rule(s): _none_ – default behavior

[[sortedOutput]]
==== sortedOutput

Type: String

Default Value: "false"

Explanation:

* If "false", the types in a schema will be processed in random order.
* If "true", the types will be processed alphabetically.
* If "taggedValue=<tag>", the types will be processed in the order of
the values of the tagged value with name "<tag>".

Applies to Rule(s): _none_ - this is a common target parameter

[[writeMapEntries]]
==== writeMapEntries

Required / Optional: optional

Type: Boolean

Default Value: false

Explanation: If set to "true", a map entry file will be written for each
processed schema, containing a map entry for each encoded type from that
schema.

Applies to Rule(s): _none_ - this is a common target parameter

[[Map_Entries]]
== Map Entries

<mapEntries> contain individual <MapEntry> elements, which for this
target contain information for mapping specific types (classes) from the
UML model to either JSON Schema simple types, or using references to
specific JSON Schema definitions.

Examples:

[source,xml,linenumbers]
----------
<mapEntries>
 <MapEntry type="CharacterString" rule="*" targetType="string" param=""/>
 <MapEntry type="URI" rule="*" targetType="string" param="keywords{format=uri}"/>
 <MapEntry type="Boolean" rule="*" targetType="boolean" param=""/>
 <MapEntry type="Integer" rule="*" targetType="integer" param=""/>
 <MapEntry type="Real" rule="*" targetType="number" param=""/>
 <MapEntry type="Measure" rule="*" targetType="number" param=""/>
 <MapEntry type="DateTime" rule="*" targetType="string" param="keywords{format=date-time}"/>
 <MapEntry type="GM_Point" rule="*" targetType="https://geojson.org/schema/Point.json" param="geometry"/>
</mapEntries>
----------

A <MapEntry> element contains the attributes described in the following
sections.

NOTE: StandardMapEntries_JSON.xml defines standard mappings for a number
of types of the ISO Harmonized Model. This file can be included in
ShapeChange configuration files (via XInclude - see the configuration
example). Additional XInclude files, or individual <MapEntry> elements
added to the <mapEntries> section of the configuration file, may be used
to customize the map entries to support additional pre-defined
conceptual UML classes.

[[type]]
=== type

Required / Optional: Required

Explanation: The unqualified UML type/class name to be mapped. Should be
unique within the model (if it is not unique, this can lead to
unexpected results).

[[rule]]
=== rule

Required / Optional: Required

Explanation: The encoding rule to which this mapping applies. May be "*"
to indicate that the mapping applies to all encoding rules.

[[targetType]]
=== targetType

Required / Optional: Required

Explanation: Name of a simple JSON Schema type (boolean, number,
integer, or string), or a reference to a particular JSON Schema,
typically expressed as a URL.

[[param]]
=== param

Required / Optional: Optional

Explanation: Defines one or more parameters for the mapping. If no
parameter is provided (leaving the 'param' attribute empty) then the map
entry contains a straightforward mapping.

Each parameter has a name. A list of parameters is separated by commas.
Each parameter can also have characteristics defined for it, providing
even further information for the conversion. Characteristics for a
parameter are provided within curly braces. A characteristic usually is
provided by a key-value pair, with the key being the identification of
the characteristic.

Examples:

* geometry
* keywords{format=date}

Supported parameters, their interpretation as well as characteristics
are described in the following sections.

[[Parameter_keywords]]
==== Parameter: keywords

Explanation: Indicates that the simple JSON type (boolean, number,
integer, string) that is the target of the map entry has one or more
restrictions defined by JSON Schema keywords. The following keywords are
supported - they also represent the characteristics of the parameter:

* for any simple JSON type: keyword _format_
* for JSON type _string_: keywords _enum_, _const_, _pattern_,
_maxLength_, _minLength_
** NOTE: Complex regular expressions intended to be used as _pattern_
may need to be base64 encoded, in order to avoid problems with syntax
rules of the map entry parameter. For base64 encoded regular
expressions, use the _patternBase64_ characteristic (instead of
_pattern_).
* for JSON types _integer_ and _number_: keywords _enum_, _const_,
_multipleOf_, _maximum_, _minimum_, _exclusiveMaximum_,
_exclusiveMinimum_

NOTE: Multiple keywords may be specified as a semicolon-delimited list, e.g.: "keywords{minimum=0;maximum=3}".

[[Parameter_encodingInfos]]
==== Parameter: encodingInfos

Explanation: Provides additional information about the JSON encoding of
the type, which is relevant for creating a JSON encoding that uses that
type.

Characteristics:

* entityTypeMemberPath: The path to the JSON member that is used to
encode the type name. Only used if the JSON encoding actually has such a
member. Examples:
** a plain JSON encoding: "@type"
** a nested JSON encoding, e.g. GeoJSON encoding: "properties/@type"
** JSON-FG encoding: "featureType"
* entityTypeMemberRequired (supported since v2.14.0): true, if the property identified by characteristic
_entityTypeMemberPath_ is declared as required in the referenced JSON Schema
definition, else false (the default). Example(s):
** JSON-FG encoding: "false"
* idMemberPath (supported since v2.14.0): The path to the JSON member that is used to encode the ID.
Only used if the JSON encoding actually has such a member. Examples:
** GeoJSON encoding: "id"
** JSON-FG encoding: "id"
* idMemberRequired (supported since v2.14.0): true, if the property identified by characteristic
_idMemberPath_ is declared as required in the referenced JSON Schema
definition, else false (the default). Examples:
** GeoJSON encoding: "false"
** JSON-FG encoding: "false"
* idMemberTypes (supported since v2.14.0): (comma-separated) list of simple JSON Schema types, in which
the value of the ID member (identified by _idMemberPath_) can be encoded.
Allowed values are _string_, _integer_, _number_. The default value for this
characteristic is _string_. Examples:
** GeoJSON encoding: "string,number"
** JSON-FG encoding: "string,number"
* idMemberFormats (supported since v2.14.0): (comma-separated) list of format identifiers, which are
assigned to keyword _format_ for the ID member in the referenced JSON Schema
definition. This characteristic has no default value.



[[Parameter_geometry]]
==== Parameter: geometry

Explanation: Indicates that the map entry contains a mapping for a
geometry type (specifically from ISO 19107). IMPORTANT: If geometry
types are not identified via map entries containing this parameter then
ShapeChange cannot determine geometry typed properties, which is
relevant for default geometry encoding!

Characteristics: _no specific characteristics are defined for this
parameter_

[[Parameter_ignoreForTypeFromSchemaSelectedForProcessing]]
==== Parameter: ignoreForTypeFromSchemaSelectedForProcessing

Explanation: Set this parameter on map entries for types from external
schemas, whose type name is the same as one of the types from the
schemas selected for processing. For example, the SWE Common 2.0 schema
defines a type called 'Boolean' - which is the same name as a type from
ISO 19103 ('Boolean'). If the parameter is set on a map entry for
'Boolean', then the type from the schema selected for processing is
still encoded and used - otherwise it would not be encoded and instead
mapped as defined by the map entry.

Characteristics: _no specific characteristics are defined for this
parameter_


[[Annotations]]
== JSON Schema Annotations

(since v2.14.0)

The target supports two types of configuration elements for defining JSON Schema annotations.

* SimpleAnnotation - For annotations with a simple JSON value, or an array thereof.
* TemplateAnnotation - For annotations with a JSON string as value, or an array thereof, defined via a template that can include multiple descriptors and tagged values.

NOTE: Annotations are only created for a model element if <<rule-json-all-documentation>> is part of the applicable encoding rule.

NOTE: The JSON Schema annotation "examples" is an example for an annotation that has a JSON array as value, with the type of array items being unrestricted. In other words, the array can contain mixed value types. The "examples" annotation can thus have an array of strings (e.g., ["abc","xyz"]), numbers (e.g., [4,2]), booleans (e.g., [true, true]), and a mix thereof (e.g., ["abc", 2, true]) as value.

NOTE: ShapeChange JSON Schema annotation elements are not designed to support the creation of annotations with complex JSON arrays or objects as value. Only simple values, or an array thereof, can be created. So far, no use cases have been identified that require a more complex annotation value. In the future, if such use cases were identified, ShapeChange could be extended to support them.

The following two tables document the structure of the two ShapeChange JSON Schema annotation elements. <<example_shapechange_jsonschema_annotation_elements>>, <<example_shapechange_advancedprocessconfigurations_with_xinclude>>, and <<example_shapechange_myJsonSchemaAnnotations>> provide configuration examples.

[#table_jsonschema_annotation_element1,reftext='{table-caption} {counter:table-num}']
.SimpleAnnotation
[cols="1,1,1,1,6a",options="header"]
|===
| Configuration Information Item | Datatype & Structure | Required / Optional | Default Value | Description
| annotation | string | Required | _not applicable_ | Name of the JSON Schema annotation keyword that shall be added to the JSON Schema element which represents the UML model element.
| appliesTo | enum: _all_, _package_, _class_, _property_, _attribute_, _role_ | Optional | _all_ | Identifies the type of model element to which the annotation applies.
| arrayValue | boolean | Optional | _false_ | If true, then the annotation value will always be encoded as an array, even if only a single value is present. Otherwise, the default behavior is to only encode multiple values within a JSON array.
| descriptorOr TaggedValue | string | Required | _not applicable_ | Either a _descriptor-ID_, identifying one of the <<table_descriptors,well-known descriptors>>, or a string identifying a tagged value.

In order to identify a tagged value, add prefix "TV:" to the name of the tagged value. If a tagged value is known to contain a list of values, combined in a string using a specific separator, and these values shall be used as individual values, rather than using the whole string as value, use the prefix "TV(_separator_):," followed by the tag name. ShapeChange will then split the tagged value around matches of the given separator (which is treated as a literal).
| noValueBehavior | enum: _ignore_ or _populateOnce_ | Optional | _ignore_ | Determines the behavior in case that no value is available for the descriptor or tagged value.

* _ignore_: No annotation is created.
* _populateOnce_: A single annotation is created, with the _noValueValue_ being used as value.
| noValueValue | string | Optional | _the empty string_ | If the descriptor or tagged value has no value, then this information item provides the value to use instead (e.g., 0, or true).
| type | enum: _string_, _integer_, _number_, _boolean_ | Optional | _string_ | Defines how ShapeChange will encode the values of the descriptor / tagged value.

* type = string: each value will be quoted
* type = integer: each value will be parsed as an integer (invalid values will be ignored, and a warning logged); values will not be quoted
* type = number: each value will be parsed as a double (invalid values will be ignored, and a warning logged); values will not be quoted
* type = boolean: if the value is "true" (ignoring case") or 1, the value will be encoded as the JSON value __true__; otherwise, it will be encoded as the JSON value __false__.

|===

[#table_jsonschema_annotation_element2,reftext='{table-caption} {counter:table-num}']
.TemplateAnnotation
[cols="1,1,1,1,6a",options="header"]
|===
| Information Item | Datatype & Structure | Required / Optional | Default Value | Description
| annotation 4+| as defined in the <<table_jsonschema_annotation_element1,previous table>>
| appliesTo 4+| as defined in the <<table_jsonschema_annotation_element1,previous table>>
| arrayValue 4+| as defined in the <<table_jsonschema_annotation_element1,previous table>>
| valueTemplate | string | Required | _not applicable_ | Textual template where an occurrence of the field "[[_descriptor-ID_]]" is replaced with the value(s) of that descriptor. The IDs of supported descriptors are listed in <<table_descriptors>>.

An occurrence of the field "\[[TV:name]]" is replaced with the value(s) of the UML tagged value with the given name from the input schema.

The content of a tagged value can also be split into multiple parts. In that case, use field "[[TV(_separator_):name]]." The tagged value will be split around matches of the given separator (which is treated as a literal).

| noValueBehavior | enum: _ignore_ or _populateOnce_ | Optional | _ignore_ | Determines the behavior in case that no value is available for any of the fields (tagged values and descriptors) contained in the template.

* _ignore_: No annotation is created.
* _populateOnce_: A single annotation is created, with the _noValueValue_ being used for all fields.
| noValueValue | string | Optional | _the empty string_ | If a descriptor used in a template has no value, then this information item provides the value to use instead (e.g., "N/A" or "FIXME").
| multiValueBehavior | enum: either _connectInSingle_ +
_AnnotationValue_ or _createMultiple_ +
_AnnotationValues_ (note that the two enums are only split in this table cell for presentation purposes) | Optional | _connectInSingle_ +
_AnnotationValue_ | Specifies how a case where one or more of the descriptors and tagged values contained in the template have multiple values, shall be encoded.

* _connectInSingleAnnotationValue_: Multiple values of a descriptor or tagged value contained in the template are combined in a single string value, using the _multiValueConnectorToken_ to connect them.
* _createMultipleAnnotationValues_: Multiple values for one or more descriptor or tagged value result in an array of annotation values, with one value for each combination of multi-valued descriptors / tagged values (resulting in a permutation of the values of each descriptor / tagged value contained in the template).
| multiValue ConnectorToken | string | Optional | _a single space character_ | If a descriptor or tagged value used in the _valueTemplate_ has multiple values, and the _multiValueBehavior_ is set to _connectInSingleAnnotationValue_, then the values are concatenated to a single string value using this token as connector between two values.
|===

NOTE: Conversion rules exist to populate the annotations "default" and "readOnly" (see <<rule-json-prop-initialValueAsDefault>>, <<rule-json-prop-derivedAsReadOnly>>, and <<rule-json-prop-readOnly>>).

The annotation elements are configured within the `<advancedProcessConfigurations>` element of the JSON Schema target, as shown in <<#example_shapechange_jsonschema_annotation_elements>>.

[#example_shapechange_jsonschema_annotation_elements,reftext='{listing-caption} {counter:listing-num}']
.Configuration example for JSON Schema annotation elements
[source,xml,linenumbers]
----
<Target class="de.interactive_instruments.ShapeChange.Target.JSON.JsonSchemaTarget" mode="enabled" inputs="model">
  <advancedProcessConfigurations>
    <JsonSchemaAnnotations>
      <annotations>
        <SimpleAnnotation annotation="title" descriptorOrTaggedValue="alias" noValueBehavior="ignore"/>
        <TemplateAnnotation annotation="description" valueTemplate="Definition: [[definition]]  Description: [[description]]" noValueValue="[None Specified]" noValueBehavior="populateOnce"/>
        <SimpleAnnotation annotation="unit" descriptorOrTaggedValue="TV:unit" noValueBehavior="ignore"/>
        <SimpleAnnotation annotation="label" descriptorOrTaggedValue="TV(|):aliasList" arrayValue="false"/>
        <SimpleAnnotation annotation="label2" descriptorOrTaggedValue="TV(|):aliasList" arrayValue="true"/>
        <SimpleAnnotation annotation="deprecated" descriptorOrTaggedValue="TV:deprecated" type="boolean"/>
        <SimpleAnnotation annotation="code" descriptorOrTaggedValue="TV:codeNumber" noValueBehavior="populateOnce" noValueValue="0" type="integer" appliesTo="class"/>
        <SimpleAnnotation annotation="code" descriptorOrTaggedValue="TV:codeNumber" noValueBehavior="populateOnce" noValueValue="0" type="integer" appliesTo="property"/>
        <TemplateAnnotation annotation="isDefinedBy" valueTemplate="http://example.org/view?i=[[TV(,):item]]" multiValueBehavior="createMultipleAnnotationValues"/>
        <SimpleAnnotation annotation="examples" descriptorOrTaggedValue="example" arrayValue="true"/>
      </annotations>
    </JsonSchemaAnnotations>
  </advancedProcessConfigurations>
  <targetParameter name="outputDirectory" value="testResults/json/documentation/json_schemas/plainjson"/>
  <targetParameter name="sortedOutput" value="true"/>
  <targetParameter name="jsonBaseUri" value="https://example.org/baseuri_from_config"/>
  <targetParameter name="linkObjectUri" value="http://example.org/jsonschema/link.json"/>
  <targetParameter name="byReferenceJsonSchemaDefinition" value="https://example.org/jsonschema/byreference.json"/>
  <targetParameter name="defaultEncodingRule" value="myPlainJson"/>
  <rules>
    <EncodingRule name="myPlainJson" extends="defaultPlainJson">
      <rule name="rule-json-all-documentation"/>
    </EncodingRule>
  </rules>
  <xi:include href="src/main/resources/config/StandardMapEntries_JSON.xml"/>
</Target>

----

The `<advancedProcessConfigurations>` element can also reference another XML file that contains the annotation definitions via an include element. That can be useful, in case that multiple JSON Schema target configurations use the same set of annotations.

[#example_shapechange_advancedprocessconfigurations_with_xinclude,reftext='{listing-caption} {counter:listing-num}']
.Example of advancedProcessConfigurations element with include statement
[source,xml,linenumbers]
----
<advancedProcessConfigurations>
  <xi:include href="./config/myJsonSchemaAnnotations.xml"/>
</advancedProcessConfigurations>

----

[#example_shapechange_myJsonSchemaAnnotations,reftext='{listing-caption} {counter:listing-num}']
.Example of included XML file with JSON Schema annotation elements
[source,xml,linenumbers]
----
<?xml version="1.0" encoding="UTF-8"?>
<JsonSchemaAnnotations xmlns="http://www.interactive-instruments.de/ShapeChange/Configuration/1.1">
  <annotations>
    <SimpleAnnotation annotation="title" descriptorOrTaggedValue="alias" noValueBehavior="ignore"/>
    <TemplateAnnotation annotation="description" valueTemplate="Definition: [[definition]]  Description: [[description]]" noValueValue="[None Specified]" noValueBehavior="populateOnce"/>
    <SimpleAnnotation annotation="unit" descriptorOrTaggedValue="TV:unit" noValueBehavior="ignore"/>
    <SimpleAnnotation annotation="label" descriptorOrTaggedValue="TV(|):aliasList" arrayValue="false"/>
    <SimpleAnnotation annotation="label2" descriptorOrTaggedValue="TV(|):aliasList" arrayValue="true"/>
    <SimpleAnnotation annotation="deprecated" descriptorOrTaggedValue="TV:deprecated" type="boolean"/>
    <SimpleAnnotation annotation="code" descriptorOrTaggedValue="TV:codeNumber" noValueBehavior="populateOnce" noValueValue="0" type="integer" appliesTo="class"/>
    <SimpleAnnotation annotation="code" descriptorOrTaggedValue="TV:codeNumber" noValueBehavior="populateOnce" noValueValue="0" type="integer" appliesTo="property"/>    
    <TemplateAnnotation annotation="isDefinedBy" valueTemplate="http://example.org/view?i=[[TV(,):item]]" multiValueBehavior="createMultipleAnnotationValues" />
    <SimpleAnnotation annotation="examples" descriptorOrTaggedValue="example" arrayValue="true"/>
  </annotations>
</JsonSchemaAnnotations>

----

[[Configuration_Example]]
== Configuration Example

[source,xml,linenumbers]
----------
<Target class="de.interactive_instruments.ShapeChange.Target.JSON.JsonSchemaTarget" mode="enabled">
 <targetParameter name="outputDirectory" value="results/json_schema/2019-09"/>
 <targetParameter name="sortedOutput" value="true"/>
 <targetParameter name="jsonBaseUri" value="https://example.org/baseuri"/>
 <targetParameter name="byReferenceJsonSchemaDefinition" value="https://example.org/jsonschema/byreference.json"/>
 <targetParameter name="entityTypeName" value="@type"/>
 <targetParameter name="defaultEncodingRule" value="myGeoJson"/>
 <rules>
  <EncodingRule name="myGeoJson" extends="defaultGeoJson">
   <rule name="rule-json-cls-basictype"/>
   <rule name="rule-json-cls-codelist-uri-format"/>
   <rule name="rule-json-cls-name-as-entityType"/>
   <rule name="rule-json-cls-union-propertyCount"/>
   <rule name="rule-json-cls-valueTypeOptions"/>
  </EncodingRule>
 </rules>
 <xi:include href="https://shapechange.net/resources/config/StandardMapEntries_JSON.xml"/>
</Target>
----------
